//-*- mode: c++; indent-tabs-mode: t; tab-width: 4; local-preserve-whitespace: t; -*-

extern void object::Slave() 
{
	object o = radar(BotFactory);
	if (o != null && distance(position, o.position) < 2) {
		//back out of the bot factory
		move(-7);
	}
	
	//register as a slave
	CommandCenter command = new CommandCenter();
	object myThis = this;
	SlaveInfo info = command.registerSlave(myThis);
	
	int task;
	while(true) {
		task = info.command;
		if (task > 0) break;
		wait(1); 
	}
	
	//mark busy
	info.status = info.BUSY;
	info.command = 0;
	performTask(task, info.params);
	//mark free
	info.status = info.FREE;
}

void object::performTask(int task, float[] params) {
	if (task == 1) {
		collect(params);
	} else if (task == 2) {
		load(params);
	} else {
		message("Unrecognized task code: " + task, DisplayError);
	}
}

//gathers a type of resource to location
void object::collect(float[] params) {
	float resource = params[0];
	point dropOff = new point(params[1], params[2]);
	bool shouldWait = (params[3] != 0);
	
	Bot me(this);
	me.hoverHeight = 5;
	
	while(me.get(resource, dropOff, 30, shouldWait)) {
		me.deposit(dropOff);
	}
	
	message("No more!");
}

//loads a certain number of a resource onto the ship
void object::load(float[] params) {
	float resource = params[0];
	int count = params[1];
	
	Bot me(this);
	me.hoverHeight = 5;
	
	object ship = radar(SpaceShip);
	
	for (int i = 0; i < count; i++ ) {
		me.get(resource, ship.position, 30, false);
		
		//find a good spot on the ship
		point p = findShipSpot();
		me.bot_goto(p, 1);
		drop();
	}
}

point findShipSpot() {
	int stride = 1;
	
	object o = radar(SpaceShip);
	point origin = o.position;
	point p = origin;
	
	for (int side = 1; side < 50; side++) {
		p.y = origin.y - stride * side;
		for (p.x = origin.x - stride * side; p.x < origin.x + 0.1 + stride * side; p.x += stride) {
			o = search(0, p);
			if (distance2d(p, o.position) > 1.5) return p;
		}
		
		p.x = origin.x + stride * side;
		for (p.y = origin.y - stride * side; p.y < origin.y + 0.1 + stride * side; p.y += stride) {
			o = search(0, p);
			if (distance2d(p, o.position) > 1.5) return p;
		}
		 
		p.y = origin.y + stride * side;
		for (p.x = origin.x + stride * side; p.x > origin.x - 0.1 - stride * side; p.x -= stride) {
			o = search(0, p);
			if (distance2d(p, o.position) > 1.5) return p;
		}
		
		p.x = origin.x - stride * side;
		for (p.y = origin.y + stride * side; p.y > origin.y - 0.1 - stride * side; p.y -= stride) {
			o = search(0, p);
			if (distance2d(p, o.position) > 1.5) return p;
		}
	}
}