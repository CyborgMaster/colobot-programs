//-*- mode: c++; indent-tabs-mode: t; tab-width: 4; local-preserve-whitespace: t; -*-

extern void object::Master() {}

public class Goal {
	static Const const = new Const();
	
	string type;
	int botType;
	string[] params;
	bool completed = false;
	Goal[] requirements = null;
	
	void Goal(string _type, int _botType, string _params) {
		int rNeeded;
		Goal subGoal;

		type = _type;
		botType = _botType;
		params = split(_params);
		
		//check for prereqs
		if (type == "buildBot") {
			//ensure research
			rNeeded = botResearch(strval(params[0]));
			subGoal = new Goal("research", WheeledGrabber, "" + rNeeded);
			if (!subGoal.completed) {
				requirements[sizeof(requirements)] = subGoal;
			}
			
			//assume we have titanium and power cell for now
			
		} else if (type == "research") {
			rNeeded = strval(params[0]);
			//remove research already completed
			rNeeded &= ~info(const.INFO_RESEARCH_DONE);
			if (rNeeded == 0) {
				completed = true;
				return;
			}
			//make sure needed research is available on this level
			rNeeded = strval(params[0]);
			if ((rNeeded & ~info(const.INFO_RESEARCH_AVAILABLE)) != 0) {
				message("Research not available!", DisplayError);
				return;
			}
			
			//assume we have power cell for now
			
		} else {
			message("Unrecognized goal type! " + type, DisplayError);
		}
	}

	Goal nextGoal() {
		if (sizeof(requirements) == 0) return this;
		return requirements[0].nextGoal();
	}

	void execute(object bot) {
		Goal that = this;
		bot.performTask(that.type, that.params);
	}
}

public string[] split(string in) {
	string[] res;
	int count = 0;
	
	while(true) {
		int loc = strfind(in, ",");
		if (loc == nan) break;
		res[count++] = strleft(in, loc);
		in = strmid(in, loc + 1);
	}
	res[count] = in;
	return res;
}

public class SlaveInfo {
	static int FREE = 0;
	static int BUSY = 1;
	
	object bot;
	int status;
	int command;
	float[] params;
	
	void SlaveInfo(object slaveBot) {
		bot = slaveBot;
		status = FREE;
		command = -1;
	}
}

public class CommandCenter {
	static SlaveInfo slaves[] = null;
	static Goal[] goals;
	static Const const = new Const();
	
	synchronized void addGoal(string type, int botType, string params) {
		goals[sizeof(goals)] = new Goal(type, botType, params);
		
		message("goals: " + sizeof(goals));
	}
	
	synchronized void resetGoals() {
		Goal[] empty;
		goals = empty;
	}

	Goal nextGoal() {
		if (sizeof(goals) == 0) return null;
		return goals[0].nextGoal();
	}

	
	void checkForUnregisteredSlaves(object that) {
		
		float minDis = 0;
		while (true) {
			object o = radar(const.ALL_BOTS, 1, 360, minDis, 100);
			if (o == null) return;
			if (o != that) {
				if (!isRegistered(o)) {
					message("Registering slave: " + o.category);
					loadprogram(o, 1, "program\\slave.txt");
					runprogram(o, 1);
					while (!isRegistered(o)) wait(1);
				}
			}
			
			minDis = distance(that.position, o.position) + 0.05; 
		}
	}
	
	bool isRegistered(object slaveBot) {
		for (int i = 0; i < sizeof(slaves); i++) {
			if (slaves[i].bot == slaveBot) {
				return true;
			}
		}
		
		return false;
	}
	
	synchronized SlaveInfo registerSlave(object slaveBot) {
		//check to see if we already have this slave
		for (int i = 0; i < sizeof(slaves); i++) {
			if (slaves[i].bot == slaveBot) {
				message("Slave tried to register twice", DisplayWarning);
				return slaves[i];
			}
		}
		
		//register new slave
		SlaveInfo newInfo = new SlaveInfo(slaveBot);
		slaves[sizeof(slaves)] = newInfo;
		return newInfo;
	}
	
	SlaveInfo getFreeSlave(int type) {
		for (int i = 0; i < sizeof(slaves); i++) {
			if(slaves[i].status == 0 /*FREE*/ && slaves[i].bot.category == type) return slaves[i];
		}
		
		return null;
	}
	
	SlaveInfo waitFreeSlave(int type) {
		SlaveInfo slave;
		while(true) {
			slave = getFreeSlave(type);
			if (slave != null) return slave;
			wait(1);
		}
	}
}
