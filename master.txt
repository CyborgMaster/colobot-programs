extern void object::Master() {}

public class Goal {
	static int NONE = 0;
	static int IN_PROGRESS = 1;
	static int DONE = 2;

	static Const const = new Const();

	string type;
	int botType;
	string[] params;
	int status = 0; //NONE
	Goal[] requirements = null;

	void Goal(string _type, int _botType, string _params) {
		message("constructor");
		CommandCenter command = new CommandCenter();
		message("command inited");
		SlaveInfo actor;
		int[] rNeeded;
		object o;

		type = _type;
		botType = _botType;
		message(_params);
		params = split(_params);
		message("" + params);

		//check for prereqs

		//make sure we have the bot required for the task
		message("finding actor");
		actor = command.getFreeSlave(_botType);
		if (actor == null) {
			message("need to build bot");
			addSubGoal(new Goal("buildBot", WheeledGrabber, ""+botType));
		}
		message("actor found");

		if (type == "buildBot") {
			//ensure research
			rNeeded = botResearch(strval(params[0]));
			addSubGoal(new Goal("research", WheeledGrabber, ""+rNeeded));
			//ensure factory
			ensureBuilding(BotFactory);
			//assume we have titanium and power cell for now

		} else if (type == "buildBuilding") {
			//TODO: check if the building type is available

			//assume we have the titanium

		} else if (type == "research") {
			// rNeeded = strval(params[0]);
			// //remove research already completed
			// rNeeded &= ~info(const.INFO_RESEARCH_DONE);
			// if (rNeeded == 0) {
			// 	status = DONE;
			// 	return;
			// }
			// //make sure needed research is available on this level
			// rNeeded = strval(params[0]);
			// if ((rNeeded & ~info(const.INFO_RESEARCH_AVAILABLE)) != 0) {
			// 	message("Research not available!", DisplayError);
			// 	return;
			// }

			//make sure we have a research center
			ensureBuilding(ResearchCenter);

			//assume we have power cell for now

		} else if (type == "load") {
			//check for adequate power
			if (actor != null) {
				o = radar(strval(params[0]));
				if (actor.bot.energyCell.energyLevel * const.FLYING_RANGE <
					distance2d(actor.bot.position, o.position)) {
					ensureBuilding(PowerStation);
				}
			}
		} else if (type == "board") {
			//no sub goals
		} else {
			message("Unrecognized goal type! " + type, DisplayError);
		}
	}

	Goal nextGoal(int bot) {
		//check sub goals
		for (int i = 0; i < sizeof(requirements); i++) {
			if (requirements[i].status == NONE) {
				return requirements[i].nextGoal(bot);
			}
		}

		if (status == NONE && botType == bot) return this;
		else return null;
	}

	void ensureBuilding(int buildingType) {
		object o = radar(buildingType);
		if (o == null) {
			addSubGoal(new Goal("buildBuilding", WheeledGrabber,
								""+buildingType));
		}
	}

	void addSubGoal(Goal subGoal) {
		if (subGoal.status == NONE) {
			requirements[sizeof(requirements)] = subGoal;
		}
	}
}

public void object::performGoal(Goal goal) {
	string type = goal.type;
	string[] params;
	params = goal.params;

	if (type == "research") {
		this.performResearch(strval(params[0]));
	} else if (type == "buildBot") {
		buildBot(strval(params[0]));
	} else if (type == "buildBuilding") {
		this.buildBuilding(strval(params[0]));
		//} else if (type == "collect") {
		//collect(params);
	} else if (type == "load") {
		this.load(strval(params[0]), strval(params[1]));
	} else if (type == "board") {
		this.board();
	} else {
		message("Unrecognized task code: " + goal.type, DisplayError);
	}
}

public string[] split(string in) {
	string[] res;
	int count = 0;

	while(true) {
		int loc = strfind(in, ",");
		message("" + loc);
		if (loc == -1) break;
		res[count++] = strleft(in, loc);
		in = strmid(in, loc + 1);
	}
	res[count] = in;
	return res;
}

public class SlaveInfo {
	static int FREE = 0;
	static int BUSY = 1;

	object bot;
	int status;
	Goal goal;

	void SlaveInfo(object slaveBot) {
		bot = slaveBot;
		status = FREE;
		goal = null;
	}
}

public class CommandCenter {
	static Const const = new Const();
	static SlaveInfo slaves[] = null;
	static Goal[] goals = null;
	static bool completed = false;
	static bool staticInit = true;

	synchronized void addGoal(string type, int botType, string params) {
		message("adding goal: " + type);
		goals[sizeof(goals)] = new Goal(type, botType, params);
	}

	synchronized void resetGoals() {
		Goal[] empty;
		goals = empty;
	}

	synchronized Goal nextGoal(int bot) {
		for (int i = 0; i < sizeof(goals); i++) {
			Goal g = goals[i].nextGoal(bot);
			if (g != null) return g;
		}
		return null;
	}

	synchronized void checkCompletion() {
		if (completed) return;
		for (int i = 0; i < sizeof(goals); i++) {
			if (goals[i].status != goals[i].DONE) return;
		}

		//mission done!!!
		message("Done! Board Spaceship!");
		completed = true;
	}
	void checkForUnregisteredSlaves(object that) {

		float minDis = 0;
		while (true) {
			object o = radar(const.ALL_BOTS, 1, 360, minDis, 100);
			if (o == null) return;
			if (o != that) {
				if (!isRegistered(o)) {
					message("Registering slave: " + o.category, DisplayInfo);
					int ret = 0;
					ret += o.loadProgram(1, "savegame/Jeremy/program/slave.txt");
					// ret += runprogram(o, 1);
					if (ret == 0) {
						while (!isRegistered(o)) wait(1);
					} else {
						message("Couldn't register", DisplayWarning);
					}
				}
			}

			minDis = distance(that.position, o.position) + 0.05;
		}
	}

	bool isRegistered(object slaveBot) {
		for (int i = 0; i < sizeof(slaves); i++) {
			if (slaves[i].bot == slaveBot) {
				return true;
			}
		}

		return false;
	}

	synchronized SlaveInfo registerSlave(object slaveBot) {
		//check to see if we already have this slave
		for (int i = 0; i < sizeof(slaves); i++) {
			if (slaves[i].bot == slaveBot) {
				//message("Slave tried to register twice", DisplayWarning);
				return slaves[i];
			}
		}

		//register new slave
		SlaveInfo newInfo = new SlaveInfo(slaveBot);
		slaves[sizeof(slaves)] = newInfo;
		return newInfo;
	}

	SlaveInfo getFreeSlave(int type) {
		for (int i = 0; i < sizeof(slaves); i++) {
			if(slaves[i].status == 0 /*FREE*/ && slaves[i].bot.category == type) return slaves[i];
		}

		return null;
	}

	SlaveInfo waitFreeSlave(int type) {
		SlaveInfo slave;
		while(true) {
			slave = getFreeSlave(type);
			if (slave != null) return slave;
			wait(1);
		}
	}
}

public void object::slave()
{
	object o = radar(BotFactory);
	if (o != null && distance(position, o.position) < 2) {
		//back out of the bot factory
		move(-7);
	}

	//register as a slave
	CommandCenter command = new CommandCenter();
	object that = this;
	//message(""+that);
	SlaveInfo info = command.registerSlave(that);

	while (true) {
		while(info.goal == null) {
			info.goal = command.nextGoal(that.category);
			if (info.goal != null) break;
			wait(1);
			command.checkCompletion();
		}

		message("New goal: " + info.goal.type, DisplayInfo);

		//mark busy
		info.status = info.BUSY;
		that.performGoal(info.goal);
		info.goal.status = info.goal.DONE;
		info.goal = null;
		//mark free
		info.status = info.FREE;
	}
}
