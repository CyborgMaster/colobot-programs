//-*- mode: c++; indent-tabs-mode: t; tab-width: 4; local-preserve-whitespace: t; -*-

extern void object::Master() {}

public class Goal {
	static int NONE = 0;
	static int IN_PROGRESS = 1;
	static int DONE = 2;
	
	static Const const = new Const();
	
	string type;
	int botType;
	string[] params;
	int status = 0; //NONE
	Goal[] requirements = null;
	
	void Goal(string _type, int _botType, string _params) {
		CommandCenter command = new CommandCenter();
		int rNeeded;
		Goal subGoal;
		SlaveInfo actor;
		
		type = _type;
		botType = _botType;
		params = split(_params);
		
		//check for prereqs

		//make sure we have the bot required for the task
		actor = command.getFreeSlave(_botType);
		if (actor == null) {
			subGoal = new Goal("buildBot", WheeledGrabber, ""+botType);
			if (subGoal.status == NONE) {
				requirements[sizeof(requirements)] = subGoal;
			}
		}
		
		if (type == "buildBot") {
			//ensure research
			rNeeded = botResearch(strval(params[0]));
			subGoal = new Goal("research", WheeledGrabber, "" + rNeeded);
			if (subGoal.status == NONE) {
				requirements[sizeof(requirements)] = subGoal;
			}
			
			//assume we have titanium and power cell for now
			
		} else if (type == "research") {
			rNeeded = strval(params[0]);
			//remove research already completed
			rNeeded &= ~info(const.INFO_RESEARCH_DONE);
			if (rNeeded == 0) {
				status = DONE;
				return;
			}
			//make sure needed research is available on this level
			rNeeded = strval(params[0]);
			if ((rNeeded & ~info(const.INFO_RESEARCH_AVAILABLE)) != 0) {
				message("Research not available!", DisplayError);
				return;
			}
			
			//assume we have power cell for now

		} else if (type == "load") {
			//No sub goals
		} else {
			message("Unrecognized goal type! " + type, DisplayError);
		}
	}

	Goal nextGoal(int bot) {
		//check sub goals
		for (int i = 0; i < sizeof(requirements); i++) {
			if (requirements[i].status == NONE) {
				return requirements[i].nextGoal(bot);
			}
		}

		if (status == NONE && botType == bot) return this;
		else return null;
	}

	/*
	void execute(object bot) {
		Goal that = this;
		bot.performTask(that.type, that.params);
	}
	*/
}

public string[] split(string in) {
	string[] res;
	int count = 0;
	
	while(true) {
		int loc = strfind(in, ",");
		if (loc == nan) break;
		res[count++] = strleft(in, loc);
		in = strmid(in, loc + 1);
	}
	res[count] = in;
	return res;
}

public class SlaveInfo {
	static int FREE = 0;
	static int BUSY = 1;
	
	object bot;
	int status;
	Goal goal;
	
	void SlaveInfo(object slaveBot) {
		bot = slaveBot;
		status = FREE;
		goal = null;
	}
}

public class CommandCenter {
	static SlaveInfo slaves[] = null;
	static Goal[] goals;
	static Const const = new Const();
	
	synchronized void addGoal(string type, int botType, string params) {
		goals[sizeof(goals)] = new Goal(type, botType, params);
	}
	
	synchronized void resetGoals() {
		Goal[] empty;
		goals = empty;
	}

	synchronized Goal nextGoal(int bot) {
		for (int i = 0; i < sizeof(goals); i++) {
			Goal g = goals[i].nextGoal(bot);
			if (g != null) return g;
		}
		return null;
	}

	
	void checkForUnregisteredSlaves(object that) {
		
		float minDis = 0;
		while (true) {
			object o = radar(const.ALL_BOTS, 1, 360, minDis, 100);
			if (o == null) return;
			if (o != that) {
				if (!isRegistered(o)) {
					message("Registering slave: " + o.category, DisplayInfo);
					int ret = 0;
					ret += loadprogram(o, 1, "program\\slave.txt");
					ret += runprogram(o, 1);
					if (ret == 0) {
						while (!isRegistered(o)) wait(1);
					} else {
						message("Couldn't register", DisplayWarning);
					}
				}
			}
			
			minDis = distance(that.position, o.position) + 0.05; 
		}
	}
	
	bool isRegistered(object slaveBot) {
		for (int i = 0; i < sizeof(slaves); i++) {
			if (slaves[i].bot == slaveBot) {
				return true;
			}
		}
		
		return false;
	}
	
	synchronized SlaveInfo registerSlave(object slaveBot) {
		//check to see if we already have this slave
		for (int i = 0; i < sizeof(slaves); i++) {
			if (slaves[i].bot == slaveBot) {
				//message("Slave tried to register twice", DisplayWarning);
				return slaves[i];
			}
		}
		
		//register new slave
		SlaveInfo newInfo = new SlaveInfo(slaveBot);
		slaves[sizeof(slaves)] = newInfo;
		return newInfo;
	}
	
	SlaveInfo getFreeSlave(int type) {
		for (int i = 0; i < sizeof(slaves); i++) {
			if(slaves[i].status == 0 /*FREE*/ && slaves[i].bot.category == type) return slaves[i];
		}
		
		return null;
	}
	
	SlaveInfo waitFreeSlave(int type) {
		SlaveInfo slave;
		while(true) {
			slave = getFreeSlave(type);
			if (slave != null) return slave;
			wait(1);
		}
	}
}

public void object::slave() 
{
	object o = radar(BotFactory);
	if (o != null && distance(position, o.position) < 2) {
		//back out of the bot factory
		move(-7);
	}
	
	//register as a slave
	CommandCenter command = new CommandCenter();
	object that = this;
	SlaveInfo info = command.registerSlave(that);
	
	Goal goal;
	while (true) {
		while(true) {
			goal = command.nextGoal(that.category);
			if (goal != null) break;
			wait(1); 
		}

		message("New goal: " + goal.type, DisplayInfo);
		
		//mark busy
		info.status = info.BUSY;
		info.goal = goal;
		performGoal(goal);
		goal.status = goal.DONE;
		info.goal = null;
		//mark free
		info.status = info.FREE;
	}
}
