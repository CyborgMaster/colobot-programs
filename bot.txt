extern public void BotClass() {}

public bool object::isAlive() {
	return search(category, position) == this;
}

public point nearestSafeSpot(point origin, float minDis) {
	int stride = 10;
	int aliens[];
	aliens[0] = AlienQueen;
	aliens[1] = AlienAnt;
	aliens[2] = AlienSpider;
	aliens[3] = AlienWasp;
	aliens[4] = AlienWorm;
	
	object o = search(aliens, origin);
	if (o == null || distance2d(origin, o.position) > minDis) {
		return origin;
	} 
	
	point p;
	
	for (int side = 1; side < 50; side++) {
		p.y = origin.y - stride * side;
		for (p.x = origin.x - stride * side; p.x < origin.x + 0.1 + stride * side; p.x += stride) {
			object o = search(aliens, p);
			if (o == null || distance2d(p, o.position) > minDis) {
				return p;
			} 
		}
		
		p.x = origin.x + stride * side;
		for (p.y = origin.y - stride * side; p.y < origin.y + 0.1 + stride * side; p.y += stride) {
			object o = search(aliens, p);
			if (o == null || distance2d(p, o.position) > minDis) {
				return p;
			} 
		}
		 
		p.y = origin.y + stride * side;
		for (p.x = origin.x + stride * side; p.x > origin.x - 0.1 - stride * side; p.x -= stride) {
			object o = search(aliens, p);
			if (o == null || distance2d(p, o.position) > minDis) {
				return p;
			} 
		}
		
		p.x = origin.x - stride * side;
		for (p.y = origin.y + stride * side; p.y > origin.y - 0.1 - stride * side; p.y -= stride) {
			object o = search(aliens, p);
			if (o == null || distance2d(p, o.position) > minDis) {
				return p;
			} 
		}
	}
}

public point alongDirection(point origin, float angle, float dis) {
	point p;
	p.x = origin.x + cos(angle) * dis;
	p.y = origin.y + sin(angle) * dis;
	return p;
}

public object[] allAliens() {
	object aliens[];
	int alienCount = 0;
	
	ipf(10000);
	for (int n = 0; true; n++) {
		object a = retobject(n);
		if (a == null) break;
		
		int c = a.category;
		if (c == AlienQueen ||
		    c == AlienAnt ||
		    c == AlienSpider ||
		    c == AlienWasp ||
		    c == AlienWorm) {
			aliens[alienCount++] = a;
		}
	}
	
	return aliens;
}

public class Bot {
	//States
	int NORMAL = 0;
	int REPAIRING = 1;
	int RECHARGING = 2;
	int COOLDOWN = 3;
	
	object me;
	int state;
	int stuckCount = 0;
	point lastPos;
	float hoverHeight = 10;
	
	public void Bot (object _me) {
		me = _me;
		lastPos = me.position;
		state = NORMAL;
	}
	
	public bool isFlying() {
		return me.category == WingedGrabber ||
		  me.category == WingedShooter ||
		  me.category == WingedSniffer ||
		  me.category == WingedOrgaShooter;
	}
	
	public bool get(int category, float minDistance, bool shouldWait) {
		object o;
		
		while (true) {
			o = radar(category, 0, 360, minDistance);
			if (o != null) break;
			if (!shouldWait) return false;
			wait(0.25);
		};
		
		bot_goto(o.position, 2);
		grab();
		return true;
	}
	
	public void deposit(int flag) {
		if (me.load == null) {
			message("Nothing to deposit!");
			return;
		}
		
		//find a free spot
		object o = radar(flag);
		point free = space(o.position, 0, 20, 2);
		bot_goto(free, 1);
		drop();
	}
	
	public void bot_goto(point pos, float tol) {
		if (isFlying()) {
			flyto(pos, tol, true);
		} else {
			checkPower();
			checkShields();
			goto(pos);
		}
	}
	
	public void flyto(point pos, float tollerance, bool land) {
		while(distance2d(me.position, pos) > tollerance) {
			checkTemperature();
			checkPower();
			checkShields();
			moveTo(pos, land, -1);
			wait(0.1);
		}
		
		motor(0,0);
	}
	
	public void follow(object target, float dis, int matchZ) {
		
		while(target != null && (distance(me.position, target.position) > dis ||
		    abs(direction(target.position)) > 5)) {
			checkTemperature();
			checkPower();
			checkShields();
			moveTo(target.position, false, matchZ);
			wait(0.1);
		}
		
		motor(0,0);
	}
	
	void checkPower() {
		//check for out of power
		if (state == NORMAL && me.energyCell.energyLevel < 0.25) {
			message("Recharging...");
			bot_recharge();
			message("Recharging done.");
		}
	}
	
	void checkShields() {
		if (state == NORMAL && me.shieldLevel < 0.50) {
			message("Repairing...");
			repair();
			message("Reparing done.");
		}
	}
	
	void checkTemperature() {
		//check for jet overheat
		if (state != COOLDOWN && me.temperature > 0.7) {
			int oldState = state;
			state = COOLDOWN;
			message("Cooldown...");
			point safe = nearestSafeSpot(me.position, 50);
			message("Found spot.");
			flyto(safe, 5, true);
			motor(0,0);
			jet(-1);
			while(me.temperature > 0) {
				wait(0.1);
			}
			state = oldState;
			message("Cooldown done.");
		}
	}
	
	public void moveTo(point pos, bool land, int matchZ) {
		
		//check for stuck
		if (distance(me.position, lastPos) < 0.25) {
			if (stuckCount++ >= 10) {
				message("stuck!");
				
				//try moving around it
				jet(1);
				motor(-1,-1);
				wait(1);
				turn(90);
				motor(1,1);
				wait(1);
				return;
			}
		} else {
			stuckCount = 0;
			lastPos = me.position;
		}
		
		//Set motors
		point motors;
		motors = turnTowards(pos);
		
		float d = distance2d(me.position, pos);
		float moveMult = 0.2;
		if (me.altitude > 0) moveMult = 0.05;
		
		if (land) {
			if (d > 1) {
				motors.x += d * moveMult;
				motors.y += d * moveMult;
			} else {
				motor(0,0);
				return;
			}
		} else { //if not landing, don't stop, fly through the point
			motors.x += 1;
			motors.y += 1;
		}
		
		motor(motors.x, motors.y);
		
		//Jet
		
		//check terain height
		float alt = topo(me.position);
		if (alt < 0) alt = 0;
		float fly;
		
		if (matchZ > 0 && d < matchZ) {
			fly = pos.z - me.position.z + hoverHeight;
		} else {
			fly = alt - me.position.z;
			if (!land) {
				fly += hoverHeight;
			} else if (d > 5 && d < 15) {
				fly += (d - 5) * (hoverHeight / 10) ;
			} else if (d > 15) {
				fly += hoverHeight;
			} else { // d < 5
				fly = -10;
			}
		}
		
		jet(fly * 0.2);
	}
	
	public point turnTowards(point pos) {
		float strength = direction(pos) / 45;
		point motors(strength * -1, strength);
		return motors;
	}
	
	void bot_recharge() {
		state = RECHARGING;
		
		object o = radar(PowerStation);
		bot_goto(o.position, 1);
		while(me.energyCell.energyLevel < 1) {
			wait(1);
		}
		
		state = NORMAL;
		
		//check to see if we should also repair
		o = radar(RepairCenter);
		if (me.shieldLevel < 0.90 && distance2d(me.position, o.position) < 100) {
			repair();
		}
	}
	
	public void repair() {
		state = REPAIRING;
		
		object o = radar(RepairCenter);
		bot_goto(o.position, 1);
		while(me.shieldLevel < 1) {
			wait(1);
		}
		
		state = NORMAL;
		
		//check to see if we should also recharge
		o = radar(PowerStation);
		if (me.energyCell.energyLevel < 0.75 && distance2d(me.position, o.position) < 100) {
			bot_recharge();
		}
	}
}