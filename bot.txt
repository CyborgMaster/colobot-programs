/* Ideas
 * Don't circle targets if we are really close to them
 * better verticle aim on kill
 * check recharge level based on distance to power station
 * when repairing fly higher to avoid damage
 */

extern public void BotClass() {}

public bool object::isAlive() {
	return search(category, position) == this;
}

public point nearestSafeSpot(point origin, float minDis) {
	int stride = 10;
	int aliens[];
	aliens[0] = AlienQueen;
	aliens[1] = AlienAnt;
	aliens[2] = AlienSpider;
	aliens[3] = AlienWasp;
	aliens[4] = AlienWorm;
	
	if (isSpotSafe(origin, aliens, minDis)) {
		return origin;
	} 
	
	point p;
	
	for (int side = 1; side < 50; side++) {
		p.y = origin.y - stride * side;
		for (p.x = origin.x - stride * side; p.x < origin.x + 0.1 + stride * side; p.x += stride) {
			if (isSpotSafe(p, aliens, minDis)) {
				return p;
			} 
		}
		
		p.x = origin.x + stride * side;
		for (p.y = origin.y - stride * side; p.y < origin.y + 0.1 + stride * side; p.y += stride) {
			if (isSpotSafe(p, aliens, minDis)) {
				return p;
			} 
		}
		 
		p.y = origin.y + stride * side;
		for (p.x = origin.x + stride * side; p.x > origin.x - 0.1 - stride * side; p.x -= stride) {
			if (isSpotSafe(p, aliens, minDis)) {
				return p;
			} 
		}
		
		p.x = origin.x - stride * side;
		for (p.y = origin.y + stride * side; p.y > origin.y - 0.1 - stride * side; p.y -= stride) {
			if (isSpotSafe(p, aliens, minDis)) {
				return p;
			} 
		}
	}
}

bool isSpotSafe(point p, int[] enemies, float minDis) {
	if (topo(p) < 0.5 || flatground(p, 2) < 1) return false;
	object o = search(enemies, p);
	if (o == null || distance2d(p, o.position) > minDis) {
		return true;
	} 
}

public point alongDirection(point origin, float angle, float dis) {
	point p;
	p.x = origin.x + cos(angle) * dis;
	p.y = origin.y + sin(angle) * dis;
	return p;
}

public object[] allAliens() {
	object aliens[];
	int alienCount = 0;
	
	ipf(10000);
	for (int n = 0; true; n++) {
		object a = retobject(n);
		if (a == null) break;
		
		int c = a.category;
		if (c == AlienQueen ||
		    c == AlienAnt ||
		    c == AlienSpider ||
		    c == AlienWasp ||
		    c == AlienWorm) {
			aliens[alienCount++] = a;
		}
	}
	
	return aliens;
}

public class Bot {
	//States
	int NORMAL = 0;
	int REPAIRING = 1;
	int RECHARGING = 2;
	int COOLDOWN = 3;
	
	object me;
	int state;
	int stuckCount = 0;
	point lastPos;
	
	//configurable parameters
	float hoverHeight = 10;
	float rechargeLevel = 0.25;
	bool breakOnRefit = false;
	
	public void Bot (object _me) {
		me = _me;
		lastPos = me.position;
		state = NORMAL;
	}
	
	public bool isFlying() {
		return me.category == WingedGrabber ||
		  me.category == WingedShooter ||
		  me.category == WingedSniffer ||
		  me.category == WingedOrgaShooter;
	}
	
	public bool get(int category, float minDistance, bool shouldWait) {
		object o;
		
		while (true) {
			o = radar(category, 0, 360, minDistance);
			if (o != null) break;
			if (!shouldWait) return false;
			wait(0.25);
		};
		
		bot_goto(o.position, 2);
		grab();
		return true;
	}
	
	public void deposit(int flag) {
		if (me.load == null) {
			message("Nothing to deposit!");
			return;
		}
		
		//find a free spot
		object o = radar(flag);
		point free = space(o.position, 0, 20, 2);
		bot_goto(free, 1);
		drop();
	}
	
	public bool bot_goto(point pos, float tol) {
		if (isFlying()) {
			return flyto(pos, tol, true);
		} else {
			checkPower(rechargeLevel);
			checkShields(0.5);
			goto(pos);
			
			return true;
		}
	}
	
	public bool flyto(point pos, float tollerance, bool land) {
		while(distance2d(me.position, pos) > tollerance) {
			bool refit;
			refit = checkTemperature();
			refit = checkPower(rechargeLevel) || refit;
			refit = checkShields(0.5) || refit;
			if (refit && breakOnRefit) return false;
			
			moveTo(pos, land, -1);
			wait(0.1);
		}
		
		motor(0,0);
		return true;
	}
	
	public bool follow(object target, float dis, int matchZ) {
		
		while(true) {
			if (target == null or !target.isAlive()) {
				return false;
			}
			
			if (distance(me.position, target.position) < dis &&
			    abs(direction(target.position)) < 5) {
				return true;
			}
			
			bool refit;
			refit = checkTemperature();
			refit = checkPower(rechargeLevel) || refit;
			refit = checkShields(0.5) || refit;
			if (refit && breakOnRefit) return false;
			
			point p = target.position;
			p.z += 10;
			moveTo(p, false, matchZ);
			wait(0.1);
		}
	}
	
	bool checkPower(float minLevel) {
		object o = radar(PowerStation);
		if (o == null) return false;
		
		//check for out of power
		if (state == NORMAL && me.energyCell.energyLevel < minLevel) {
			message("Recharging...");
			state = RECHARGING;
			
			bool oldRefit = breakOnRefit;
			breakOnRefit = false;
			bot_goto(o.position, 1);
			breakOnRefit = oldRefit;
			while(me.energyCell.energyLevel < 1) {
				wait(1);
			}
			state = NORMAL;
			message("Recharging done.");
			
			//check to see if we should also repair
			o = radar(RepairCenter);
			if (o != null && distance2d(me.position, o.position) < 100) {
				checkShields(0.90);
			}
			
			return true;
		}
		
		return false;
	}
	
	bool checkShields(float minLevel) {
		object o = radar(RepairCenter);
		if (o == null) return false;
		
		if (state == NORMAL && me.shieldLevel < minLevel) {
			message("Repairing...");
			state = REPAIRING;
			
			bool oldRefit = breakOnRefit;
			breakOnRefit = false;
			bot_goto(o.position, 1);
			breakOnRefit = oldRefit;
			while(me.shieldLevel < 1) {
				wait(1);
			}
			
			state = NORMAL;
			message("Reparing done.");
			
			//check to see if we should also recharge
			o = radar(PowerStation);
			if (o != null && distance2d(me.position, o.position) < 100) {
				checkPower(0.75);
			}
			
			return true;
		}
		
		return false;
	}
	
	bool checkTemperature() {
		//check for jet overheat
		if (state != COOLDOWN && me.temperature > 0.7) {
			message("Cooldown...");
			int oldState = state;
			state = COOLDOWN;
			point safe = nearestSafeSpot(me.position, 50);
			message("Found spot.");
			bool oldRefit = breakOnRefit;
			breakOnRefit = false;
			flyto(safe, 1, true);
			breakOnRefit = oldRefit;
			motor(0,0);
			jet(-1);
			while(me.temperature > 0) {
				wait(0.1);
			}
			state = oldState;
			message("Cooldown done.");
			
			return true;
		}
		
		return false;
	}
	
	public void moveTo(point pos, bool land, int matchZ) {
		
		//check for stuck
		if (distance(me.position, lastPos) < 0.25) {
			if (stuckCount++ >= 10) {
				message("stuck!");
				
				//try moving around it
				jet(1);
				motor(-1,-1);
				wait(1);
				turn(90);
				motor(1,1);
				wait(1);
				return;
			}
		} else {
			stuckCount = 0;
			lastPos = me.position;
		}
		
		//Set motors
		float ml, mr;
		
		float d = distance2d(me.position, pos);
		float moveMult = 0.2;
		if (me.altitude > 0) moveMult = 0.05;
		
		if (land) {
			if (d > 1) {
				ml = d * moveMult;
				mr = d * moveMult;
			} else {
				motor(0,0);
				return;
			}
		} else { //if not landing, don't stop, fly through the point
			ml = 1;
			mr = 1;
		}
		
		if (ml > 1) ml = 1;
		if (mr > 1) mr = 1;
		
		float strength = direction(pos) / 45;
		ml += strength * -1;
		mr += strength;
		
		motor(ml, mr);
		
		//Jet
		
		//check terain height
		float alt = topo(me.position);
		if (alt < 0) alt = 0;
		float fly;
		
		if (matchZ > 0 && d < matchZ) {
			if (pos.z < alt + 2) {
				fly = alt + 2 - me.position.z;
			} else {
				fly = pos.z - me.position.z;
			}
		} else {
			fly = alt - me.position.z;
			if (!land) {
				fly += hoverHeight;
			} else if (d > 5 && d < 5 + hoverHeight) {
				fly += (d - 5);
			} else if (d > 15) {
				fly += hoverHeight;
			} else { // d < 5
				fly = -10;
			}
		}
		
		jet(fly * 0.1);
	}
}